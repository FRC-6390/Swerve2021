"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ieee754 = require("ieee754");
const net = require("net");
const buffer_1 = require("buffer");
const url = require("url");
var strLenIdent = numTo128;
class Client {
    constructor(options) {
        this.debug = (level, st) => { };
        this.clientName = "NodeJS" + Date.now();
        this.connected = false;
        this.socketConnected = false;
        this.entries = {};
        this.oldEntries = {};
        this.keymap = {};
        this.newKeyMap = [];
        this.updatedIDs = [];
        this.reconnect = false;
        this.known = false;
        this.listeners = [];
        this.RPCExecCallback = {};
        this.lateCallbacks = [];
        this.is2_0 = false;
        this.reAssign = {};
        this.beingAssigned = [];
        this.strictInput = false;
        this.reconnectDelay = 0;
        this.tryReconnect = false;
        this.recProto = {
            /** Keep Alive */
            0x00: (buf, off) => {
                return off;
            },
            /** Protocol Version Unsupported */
            0x02: (buf, off) => {
                checkBufLen(buf, off, 2);
                var ver = `${buf[off++]}.${buf[off++]}`;
                this.debug(0 /* basic */, `version ${this.is2_0 ? '2.0' : '3.0'}`);
                this.debug(0 /* basic */, `Server supports version ${ver}`);
                if (ver === "2.0") {
                    this.reconnect = true;
                    this.is2_0 = true;
                    strLenIdent = numTo2Byte;
                }
                else
                    this.conCallback(false, new Error("Unsupported protocol: " + ver), this.is2_0);
                return off;
            },
            /** Server Hello Complete */
            0x03: (buf, off) => {
                this.debug(1 /* messageType */, 'Received Server Hello Complete');
                this.connected = true;
                for (let key in this.oldEntries) {
                    if (typeof this.entries[key] == 'undefined') {
                        let old = this.oldEntries[key];
                        this.Assign(old.val, old.name, old.flags > 0);
                    }
                }
                if (this.is2_0) {
                    this.afterConnect();
                }
                else {
                    this.newKeyMap.map(e => {
                        if (typeof this.keymap[e.name] == 'undefined') {
                            this.Assign(e.val, e.name, e.flags > 0);
                        }
                    });
                    if (this.oldEntries != null && this.reconnectDelay >= 20) {
                        let keys = Object.keys(this.oldEntries);
                        for (let i = 0; i < keys.length; i++) {
                            if (typeof this.entries[keys[i]] == 'undefined') {
                                let entry = this.oldEntries[keys[i]];
                                this.Assign(entry.val, entry.name, entry.flags);
                            }
                        }
                    }
                    this.toServer.HelloComplete();
                    if (this.known) {
                        while (this.updatedIDs.length > 0) {
                            let e = this.updatedIDs.pop();
                            if (typeof this.entries[e] != 'undefined')
                                this.Update(e, this.entries[e].val);
                        }
                    }
                }
                return off;
            },
            /** Server Hello */
            0x04: (buf, off) => {
                this.debug(1 /* messageType */, `Received Server Hello`);
                checkBufLen(buf, off, 1);
                let flags = this.is2_0 ? 0 : buf[off++];
                this.known = flags > 0;
                let sName = TypesFrom[2 /* String */](buf, off);
                this.serverName = sName.val;
                this.debug(2 /* messages */, { serverName: sName.val, isKnown: flags > 0 });
                return sName.offset;
            },
            /** Entry Assignment */
            0x10: (buf, off) => {
                let keyName = TypesFrom[2 /* String */](buf, off);
                this.debug(1 /* messageType */, `Received entry assignment for ${keyName.val}`);
                off = keyName.offset;
                checkBufLen(buf, off, 5 + (this.is2_0 ? 0 : 1));
                let type = buf[off++], id = (buf[off++] << 8) + buf[off++], typeName = typeNames[type], key = keyName.val, entry = {
                    typeID: type,
                    name: key,
                    sn: (buf[off++] << 8) + buf[off++],
                    flags: this.is2_0 ? 0 : buf[off++]
                };
                let val = TypesFrom[entry.typeID](buf, off);
                entry.val = val.val;
                this.entries[id] = entry;
                this.keymap[key] = id;
                this.callListeners(keyName.val, val.val, typeName, "add", id, entry.flags);
                if (typeof this.reAssign[key] != 'undefined') {
                    let toUpdate = this.reAssign[key];
                    this.Update(id, toUpdate.val);
                    if (!this.is2_0 && entry.flags !== toUpdate.flags) {
                        this.Flag(id, toUpdate.flags);
                    }
                    delete this.reAssign[key];
                }
                this.debug(2 /* messages */, { key: keyName.val, type, id, sequenceNumber: entry.sn, flags: entry.flags, value: entry.val });
                return val.offset;
            },
            /** Entry Update */
            0x11: (buf, off) => {
                this.debug(1 /* messageType */, 'Received an entry update');
                checkBufLen(buf, off, 4 + (this.is2_0 ? 0 : 1));
                let id = (buf[off++] << 8) + buf[off++], sn = (buf[off++] << 8) + buf[off++], type = this.is2_0 ? this.entries[id].typeID : buf[off++], val = TypesFrom[type](buf, off), typeName = typeNames[type], name = "";
                if (typeof this.entries[id] != 'undefined' && type === this.entries[id].typeID) {
                    let entry = this.entries[id];
                    entry.sn = sn;
                    entry.val = val.val;
                    name = entry.name;
                    this.callListeners(name, val.val, typeName, "update", id, entry.flags);
                }
                this.debug(2 /* messages */, { id, sequenceNumber: sn, type, value: val.val });
                return val.offset;
            },
            /** Entry Flags Update */
            0x12: (buf, off) => {
                this.debug(1 /* messageType */, 'Received a flags update');
                checkBufLen(buf, off, 3);
                let id = (buf[off++] << 8) + buf[off++], flags = buf[off++];
                if (typeof this.entries[id] != 'undefined') {
                    let entry = this.entries[id];
                    entry.flags = flags;
                    this.callListeners(entry.name, entry.val, typeNames[entry.typeID], "flagChange", id, flags);
                }
                this.debug(2 /* messages */, { id, flags });
                return off;
            },
            /** Entry Delete */
            0x13: (buf, off) => {
                this.debug(1 /* messageType */, 'Received an entry delete');
                checkBufLen(buf, off, 2);
                let id = (buf[off++] << 8) + buf[off++], name = this.entries[id].name, typename = typeNames[this.entries[id].typeID], flags = this.entries[id].flags;
                delete this.entries[id];
                delete this.keymap[name];
                this.callListeners(name, null, typename, "delete", id, flags);
                this.debug(2 /* messages */, { id });
                return off;
            },
            /** Clear All Entries */
            0x14: (buf, off) => {
                this.debug(1 /* messageType */, 'Received an entry update');
                checkBufLen(buf, off, 4);
                let val = 0;
                for (let i = 0; i < 4; i++) {
                    val = (val << 8) + buf[off + i];
                }
                if (val === 0xd06cb27a) {
                    this.entries = {};
                    this.keymap = {};
                }
                this.debug(2 /* messages */, { val, isCorrect: val === 0xd06cb27a });
                return off + 4;
            },
            /** RPC Response */
            0x21: (buf, off) => {
                this.debug(1 /* messageType */, 'Received an RPC Response');
                checkBufLen(buf, off, 4);
                let id = (buf[off++] << 8) + buf[off++], executeID = (buf[off++] << 8) + buf[off++], len = numFrom128(buf, off), res = this.entries[id].val.results, results = {}, s;
                for (let i = 0; i < res.length; i++) {
                    for (let i = 0; i < res.length; i++) {
                        s = TypesFrom[res[i].typeId](buf, off);
                        off = s.offset;
                        results[res[i].name] = s.val;
                    }
                }
                if (typeof this.RPCExecCallback[executeID] != 'undefined') {
                    this.RPCExecCallback[executeID](results);
                    delete this.RPCExecCallback[executeID];
                }
                this.debug(2 /* messages */, { id, executeID, results });
                return off;
            }
        };
        this.toServer = {
            Hello: (serverName) => {
                this.debug(1 /* messageType */, 'Sending a Hello');
                if (this.is2_0) {
                    this.write(toServer.hello2_0);
                }
                else {
                    let s = TypeBuf[2 /* String */].toBuf(serverName), buf = buffer_1.Buffer.allocUnsafe(s.length + 3);
                    buf[0] = 0x01;
                    buf[1] = 3;
                    buf[2] = 0;
                    s.write(buf, 3);
                    this.write(buf, true);
                }
            },
            HelloComplete: () => {
                this.debug(1 /* messageType */, 'Sending a Hello Complete');
                this.write(toServer.helloComplete, true);
                this.afterConnect();
            }
        };
        this.keepAlive = buffer_1.Buffer.from([0]);
        this.buffersToSend = [];
        this.callListeners = (key, val, valType, type, id, flags) => {
            for (let i = 0; i < this.listeners.length; i++) {
                if (this.connected) {
                    this.listeners[i](key, val, valType, type, id, flags);
                }
                else {
                    this.lateCallbacks.push(() => this.listeners[i](key, val, valType, type, id, flags));
                }
            }
        };
        if (options == undefined)
            return;
        if (options.strictInput)
            this.strictInput = true;
    }
    /**
     * True if the Client has completed its hello and is connected
     */
    isConnected() {
        return this.connected;
    }
    /**
     * True if the client has switched to 2.0
     */
    uses2_0() {
        return this.is2_0;
    }
    /**
     * Set and activate the reconnect feature
     *
     *
     * Delay of 20 or less will deactivate this feature
     * @param delay Time in milisecconds before the next reconnect attempt
     */
    setReconnectDelay(delay) {
        if (delay < 20) {
            this.tryReconnect = false;
            clearTimeout(this.autoReconnect);
        }
        this.reconnectDelay = delay;
        this.debug(0 /* basic */, `Setting Reconnect dellay to ${delay}`);
    }
    /**
     * Start the Client
     * @param callback Called on connect or error
     * @param address Address of the Server. Default = "localhost"
     * @param port Port of the Server. Default = 1735
     */
    start(callback, address = "127.0.0.1", port = 1735) {
        this.tryReconnect = false;
        clearTimeout(this.autoReconnect);
        /:\/\/\w/.test(address);
        let parsedAddress = url.parse((/:\/\/\w/.test(address) ? "" : "tcp://") + address);
        address = parsedAddress.hostname;
        port = parseInt(parsedAddress.port) || port;
        this.conCallback = callback;
        this.debug(0 /* basic */, `Connecting to ${address} on port ${port}`);
        this.__connect(address, port);
    }
    __connect(address, port) {
        this.reconnect = false;
        this.connected = false;
        this.address = address;
        this.port = port;
        this.reAssign = {};
        this.beingAssigned = [];
        this.client = net
            .connect(port, address, () => {
            this.socketConnected = true;
            this.toServer.Hello(this.clientName);
            this.client.on("data", data => {
                let pos = 0, buf = data;
                if (this.continuation != null) {
                    pos = this.continuation.offset;
                    buf = buffer_1.Buffer.concat([this.continuation.buf, buf]);
                    this.continuation = null;
                }
                try {
                    this.read(buf, pos);
                }
                catch (e) {
                    this.conCallback(true, e, this.is2_0);
                }
            });
        })
            .on("close", hadError => {
            this.debug(0 /* basic */, 'Closing socket');
            if (this.reconnectDelay > 20 && this.connected)
                this.tryReconnect = true;
            if (this.tryReconnect && !this.reconnect) {
                clearTimeout(this.autoReconnect);
                this.autoReconnect = setTimeout(() => {
                    this.debug(0 /* basic */, `Trying to reconnect to ${address}:${port}`);
                    this.__connect(address, port);
                }, this.reconnectDelay);
            }
            this.socketConnected = false;
            this.connected = false;
            this.oldEntries = this.entries;
            this.entries = {};
            this.keymap = {};
            let reconn;
            if (this.reconnect) {
                this.__connect(address, port);
            }
            else if (!hadError)
                this.conCallback(false, null, this.is2_0);
        })
            .on("error", err => {
            let mesgPar = err.message.split(' ');
            if (mesgPar.length < 2 || mesgPar[1] != 'ECONNREFUSED' || this.reconnectDelay < 20) {
                this.conCallback(false, err, this.is2_0);
            }
            else {
                this.conCallback(false, null, this.is2_0);
            }
        })
            .on('end', () => {
            this.socketConnected = false;
        });
    }
    /** Attempts to stop the client */
    stop() {
        this.client.end();
        this.socketConnected = false;
        this.reconnectDelay = 0;
    }
    /** Immediately closes the client */
    destroy() {
        this.client.destroy();
        this.socketConnected = false;
        this.reconnectDelay = 0;
        this.connected = false;
    }
    /**
     * Adds and returns a Listener to be called on change of an Entry
     * @param callback Listener
     */
    addListener(callback, getCurrent) {
        this.listeners.push(callback);
        if (getCurrent && this.connected) {
            for (let key in this.keymap) {
                let entry = this.entries[this.keymap[key]];
                callback(key, entry.val, typeNames[entry.typeID], "add", this.keymap[key], entry.flags);
            }
        }
        return callback;
    }
    /**
     * Removes a Listener
     * @param listener the Listener to remove
     */
    removeListener(listener) {
        var index = this.listeners.indexOf(listener);
        if (index > -1) {
            this.listeners.splice(index, 1);
        }
    }
    getKeyID(key) {
        if (key == undefined) {
            return this.keymap;
        }
        else
            return this.keymap[key];
    }
    /**
     * Gets an Entry
     * @param id ID of an Entry
     */
    getEntry(id) {
        return this.entries[id];
    }
    /**
     * Get an Array of Keys
     */
    getKeys() {
        return Object.keys(this.keymap);
    }
    /**
     * Get All of the Entries
     */
    getEntries() {
        return this.entries;
    }
    read(buf, off) {
        checkBufLen(buf, off, 1);
        if (buf.length == off)
            return;
        if (typeof this.recProto[buf[off]] != 'undefined') {
            try {
                off = this.recProto[buf[off]](buf, off + 1);
                this.read(buf, off);
            }
            catch (e) {
                if (e instanceof LengthError) {
                    this.continuation = { buf, offset: off };
                    return;
                }
                else
                    throw e;
            }
        }
        else
            throw new Error("Unknown Message Type " + buf[off]);
    }
    afterConnect() {
        this.conCallback(true, null, this.is2_0);
        while (this.lateCallbacks.length) {
            this.lateCallbacks.shift()();
        }
    }
    /**
     * Add an Entry
     * @param val The Value
     * @param name The Key of the Entry
     * @param persist Whether the Value should persist on the server through a restart
     */
    Assign(val, name, persist = false) {
        this.debug(1 /* messageType */, `Assigning ${name}`);
        let type = getType(val);
        if (this.is2_0 && type === 3 /* RawData */)
            return new Error("2.0 does not have Raw Data");
        if (type === 32 /* RPC */)
            return new Error("Clients can not assign an RPC");
        if (!this.connected) {
            let nID = this.newKeyMap.length;
            this.newKeyMap[nID] = {
                typeID: type,
                val,
                flags: +persist,
                name: name
            };
            this.listeners.map(e => e(name, val, typeNames[type], "add", -nID - 1, +persist));
            return;
        }
        if (typeof this.keymap[name] != 'undefined') {
            return this.Update(this.keymap[name], val);
        }
        if (this.beingAssigned.indexOf(name) >= 0) {
            this.reAssign[name] = { val, flags: +persist };
            return;
        }
        else {
            this.beingAssigned.push(name);
        }
        let n = TypeBuf[2 /* String */].toBuf(name), f = TypeBuf[type].toBuf(val), nlen = n.length, assignLen = this.is2_0 ? 6 : 7, len = f.length + nlen + assignLen, buf = buffer_1.Buffer.allocUnsafe(len);
        buf[0] = 0x10;
        n.write(buf, 1);
        buf[nlen + 1] = type;
        buf[nlen + 2] = 0xff;
        buf[nlen + 3] = 0xff;
        buf[nlen + 4] = 0;
        buf[nlen + 5] = 0;
        if (!this.is2_0)
            buf[nlen + 6] = +persist;
        f.write(buf, nlen + assignLen);
        this.debug(2 /* messages */, { key: name, type, flags: +persist, val });
        this.write(buf);
    }
    /**
     * Updates an Entry
     * @param id The ID of the Entry
     * @param val The value of the Entry
     */
    Update(id, val) {
        this.debug(1 /* messageType */, `Updating Entry`);
        if (id < 0) {
            let nEntry = this.newKeyMap[-id - 1];
            let testVal = this.fixType(val, nEntry.typeID);
            if (testVal != null) {
                val = testVal;
                if (this.connected) {
                    if (typeof this.keymap[nEntry.name] != 'undefined') {
                        id = this.keymap[nEntry.name];
                    }
                    else {
                        return this.Assign(val, nEntry.name, nEntry.flags > 0);
                    }
                }
                else {
                    nEntry.val = val;
                    this.listeners.map(e => e(nEntry.name, val, typeNames[nEntry.typeID], "update", id, nEntry.val));
                    return;
                }
            }
            else
                return new Error(`Wrong Type: ${val} is not a ${typeNames[nEntry.typeID]}`);
        }
        if (typeof this.entries[id] == 'undefined')
            return new Error("ID not found");
        let entry = this.entries[id], testVal = this.fixType(val, entry.typeID);
        if (testVal == null)
            return new Error(`Wrong Type: ${val} is not a ${typeNames[entry.typeID]}`);
        val = entry.val = testVal;
        entry.sn++;
        if (!this.connected) {
            if (this.updatedIDs.indexOf(id) < 0)
                this.updatedIDs.push(id);
            this.listeners.map(e => e(entry.name, val, typeNames[entry.typeID], "update", id, entry.flags));
            return;
        }
        let f = TypeBuf[entry.typeID].toBuf(val), updateLen = this.is2_0 ? 5 : 6, len = f.length + updateLen, buf = buffer_1.Buffer.allocUnsafe(len);
        buf[0] = 0x11;
        buf[1] = id >> 8;
        buf[2] = id & 0xff;
        buf[3] = entry.sn >> 8;
        buf[4] = entry.sn & 0xff;
        if (!this.is2_0)
            buf[5] = entry.typeID;
        f.write(buf, updateLen);
        this.debug(2 /* messages */, { id, sequenceNumber: entry.sn, type: entry.typeID, value: val });
        this.write(buf);
        this.listeners.map(e => e(entry.name, val, typeNames[entry.typeID], "update", id, entry.flags));
    }
    /**
     * Updates the Flag of an Entry
     * @param id The ID of the Entry
     * @param flags Whether the Entry should persist through a restart on the server
     */
    Flag(id, flags = false) {
        this.debug(1 /* messageType */, `Updating Flags`);
        if (this.is2_0)
            return new Error("2.0 does not support flags");
        if (typeof this.entries[id] == 'undefined')
            return new Error("Does not exist");
        this.debug(2 /* messages */, { id, flags: +flags });
        this.write(buffer_1.Buffer.from([0x12, id >> 8, id & 0xff, +flags]));
    }
    /**
     * Deletes an Entry
     * @param id The ID of the Entry
     */
    Delete(id) {
        this.debug(1 /* messageType */, `Delete Entry`);
        if (this.is2_0)
            return new Error("2.0 does not support delete");
        if (typeof this.entries[id] == 'undefined')
            return new Error("Does not exist");
        this.write(buffer_1.Buffer.from([0x13, id >> 8, id & 0xff]));
        this.debug(2 /* messages */, `Delete ${id}`);
    }
    /**
     * Deletes All Entries
     */
    DeleteAll() {
        this.debug(1 /* messageType */, `Delete All Entries`);
        if (this.is2_0)
            return new Error("2.0 does not support delete");
        this.write(toServer.deleteAll);
        this.entries = {};
        this.keymap = {};
    }
    /**
     * Executes an RPC
     * @param id The ID of the RPC Entry
     * @param val The Values of the Parameters
     * @param callback To be called with the Results
     */
    RPCExec(id, val, callback) {
        this.debug(1 /* messageType */, `Execute RPC`);
        if (this.is2_0)
            return new Error("2.0 does not support RPC");
        if (typeof this.entries[id] == 'undefined')
            return new Error("Does not exist");
        let entry = this.entries[id];
        if (entry.typeID !== 32 /* RPC */)
            return new Error("Is not an RPC");
        let par = entry.val.par, f = [], value, len = 0, parName = "";
        for (let i = 0; i < par.length; i++) {
            parName = par[i].name;
            value = typeof val[parName] != 'undefined' ? val[parName] : par[i].default;
            let testVal = this.fixType(value, par[i].typeId);
            if (testVal == null)
                return new Error(`Wrong Type: ${value} is not a ${typeNames[par[i].typeId]}`);
            let n = TypeBuf[par[i].typeId].toBuf(testVal);
            len += n.length;
            f.push(n);
        }
        let encLen = numTo128(len), buf = buffer_1.Buffer.allocUnsafe(len + encLen.length + 5), off = 5 + encLen.length, randId = Math.floor(Math.random() * 0xffff);
        buf[0] = 0x21;
        buf[1] = id >> 8;
        buf[2] = id & 0xff;
        buf[3] = randId >> 8;
        buf[4] = randId & 0xff;
        encLen.copy(buf, 5);
        for (let i = 0; i < f.length; i++) {
            f[i].write(buf, off);
            off += f[i].length;
        }
        this.debug(2 /* messages */, { id, randId, val });
        this.write(buf);
        this.RPCExecCallback[randId] = callback;
    }
    /**
     * Direct Write to the Server
     * @param buf The Buffer to be sent
     * @param immediate whether the write should happen right away
     */
    write(buf, immediate = false) {
        if (this.aliveTimer)
            clearTimeout(this.aliveTimer);
        if (!this.socketConnected)
            return;
        this.aliveTimer = setTimeout(() => {
            this.write(this.keepAlive);
        }, 1000);
        if (this.aliveTimer.unref)
            this.aliveTimer.unref();
        this.buffersToSend.push(buf);
        let writeFunc = () => {
            this.debug(0 /* basic */, `Writing to Server`);
            this.debug(3 /* everything */, buf);
            this.client.write(buffer_1.Buffer.concat(this.buffersToSend));
            this.bufferTimer = null;
            this.buffersToSend = [];
        };
        if (immediate) {
            writeFunc();
        }
        else {
            this.debug(3 /* everything */, 'Buffering write');
            if (this.bufferTimer == null)
                this.bufferTimer = setTimeout(writeFunc, 20);
        }
    }
    startDebug(name, debugLevel = 0 /* basic */) {
        if (typeof name == 'string' && name.length > 0) {
            this.debug = (level, st) => {
                if (level > debugLevel)
                    return;
                if (typeof st == 'string') {
                    console.log(name + ': ' + st);
                }
                else {
                    console.log({ [name]: st });
                }
            };
        }
    }
    fixType(val, type) {
        if (Array.isArray(val)) {
            if (type === 16 /* BoolArray */) {
                if (val.every(e => typeof e === "boolean"))
                    return val;
                else if (!this.strictInput) {
                    let tryVal = [];
                    for (let i = 0; i < val.length; i++) {
                        if (val[i] == "true" || val[i] == "false")
                            tryVal.push(val[i] == "true");
                        else
                            return;
                    }
                    return tryVal;
                }
            }
            else if (type === 17 /* DoubleArray */) {
                if (val.every(e => typeof e === "number")) {
                    return val;
                }
                else if (!this.strictInput) {
                    let tryVal = [];
                    for (let i = 0; i < val.length; i++) {
                        let testVal = parseFloat(val[i]);
                        if (Number.isNaN(testVal))
                            return;
                        else
                            tryVal.push(testVal);
                    }
                    return tryVal;
                }
            }
            else if (type === 18 /* StringArray */) {
                if (val.every(e => typeof e === "string")) {
                    return val;
                }
                else if (!this.strictInput) {
                    return val.map(a => a.toString());
                }
            }
        }
        else {
            if (type === 0 /* Boolean */) {
                if (typeof val === "boolean") {
                    return val;
                }
                else if (!this.strictInput &&
                    (val == "true" || val == "false")) {
                    return val == "true";
                }
            }
            else if (type === 1 /* Double */) {
                if (typeof val === "number") {
                    return val;
                }
                else if (!this.strictInput) {
                    let testVal = parseFloat(val);
                    if (!Number.isNaN(testVal)) {
                        return testVal;
                    }
                }
            }
            else if (type === 2 /* String */) {
                if (!this.strictInput || typeof val == "string")
                    return val.toString();
            }
            else if (type === 3 /* RawData */ && buffer_1.Buffer.isBuffer(val))
                return val;
        }
        if (type === 3 /* RawData */ && !this.strictInput) {
            if (typeof val == "number" &&
                val <= 0xff &&
                val >= 0 &&
                Number.isInteger(val)) {
                return buffer_1.Buffer.from([val]);
            }
            else if (Array.isArray(val) &&
                val.every(a => typeof a == "number" &&
                    a >= 0 &&
                    a <= 0xff &&
                    Number.isInteger(a))) {
                return buffer_1.Buffer.from(val);
            }
            else if (typeof val == "string") {
                return buffer_1.Buffer.from(val);
            }
        }
    }
}
exports.Client = Client;
const typeNames = {
    0x00: "Boolean",
    0x01: "Number",
    0x02: "String",
    0x03: "Buffer",
    0x10: "BooleanArray",
    0x11: "NumberArray",
    0x12: "StringArray",
    0x20: "RPC"
};
function checkTypeI(val, type) {
    if (Array.isArray(val)) {
        if (type === 16 /* BoolArray */ && val.every(e => typeof e === "boolean"))
            return true;
        else if (type === 17 /* DoubleArray */ &&
            val.every(e => typeof e === "number"))
            return true;
        else if (type === 18 /* StringArray */ &&
            val.every(e => typeof e === "string"))
            return true;
        else
            return false;
    }
    else {
        if (type === 0 /* Boolean */ && typeof val === "boolean")
            return true;
        else if (type === 1 /* Double */ && typeof val === "number")
            return true;
        else if (type === 2 /* String */ && typeof val === "string")
            return true;
        else if (type === 3 /* RawData */ && buffer_1.Buffer.isBuffer(val))
            return true;
        else
            return false;
    }
}
function getType(val) {
    if (Array.isArray(val)) {
        if (typeof val[0] === "boolean")
            return 0x10;
        else if (typeof val[0] === "number")
            return 0x11;
        else if (typeof val[0] === "string")
            return 0x12;
        else if (typeof val[0] === "object")
            return 0x20;
    }
    else {
        if (typeof val === "boolean")
            return 0x00;
        else if (typeof val === "number")
            return 0x01;
        else if (typeof val === "string")
            return 0x02;
        else if (buffer_1.Buffer.isBuffer(val))
            return 0x03;
    }
}
const toServer = {
    helloComplete: buffer_1.Buffer.from([0x05]),
    deleteAll: buffer_1.Buffer.from([0x14, 0xd0, 0x6c, 0xb2, 0x7a]),
    hello2_0: buffer_1.Buffer.from([0x01, 2, 0])
};
const TypeBuf = {
    0x00: {
        toBuf: val => {
            return {
                length: 1,
                write: (buf, off) => {
                    buf[off] = +val;
                }
            };
        },
        fromBuf: (buf, off) => {
            checkBufLen(buf, off, 1);
            return {
                offset: off + 1,
                val: buf[off] > 0
            };
        }
    },
    0x01: {
        toBuf: val => {
            return {
                length: 8,
                write: (buf, off) => {
                    ieee754.write(buf, val, off, false, 52, 8);
                }
            };
        },
        fromBuf: (buf, off) => {
            checkBufLen(buf, off, 8);
            return {
                offset: off + 8,
                val: ieee754.read(buf, off, false, 52, 8)
            };
        }
    },
    0x02: {
        toBuf: val => {
            let bufT = buffer_1.Buffer.concat([
                strLenIdent(val.length),
                buffer_1.Buffer.from(val, "utf8")
            ]);
            return {
                length: bufT.length,
                write: (buf, off) => {
                    bufT.copy(buf, off);
                }
            };
        },
        fromBuf: (buf, off) => {
            return fromLEBuf(buf, off);
        }
    },
    0x03: {
        toBuf: val => {
            let len = numTo128(val.length);
            return {
                length: val.length + len.length,
                write: (buf, off) => {
                    len.copy(buf, off);
                    val.copy(buf, off + len.length);
                }
            };
        },
        fromBuf: (buf, off) => {
            let { val, offset } = numFrom128(buf, off), nbuf = buffer_1.Buffer.allocUnsafe(val), end = offset + val;
            checkBufLen(buf, off, val);
            buf.copy(nbuf, 0, offset);
            return {
                offset: end,
                val: nbuf
            };
        }
    },
    0x10: {
        toBuf: val => {
            return {
                length: val.length + 1,
                write: (buf, off) => {
                    buf[off] = val.length;
                    for (let i = 0; i < val.length; i++) {
                        buf[off + i] = +val[i];
                    }
                }
            };
        },
        fromBuf: (buf, off) => {
            checkBufLen(buf, off, 1);
            let len = buf[off], res = [];
            off++;
            checkBufLen(buf, off, len);
            for (let i = 0; i < len; i++) {
                res.push(buf[off + i] > 0);
            }
            return {
                offset: off + len,
                val: res
            };
        }
    },
    0x11: {
        toBuf: val => {
            let len = val.length;
            return {
                length: 8 * val.length + 1,
                write: (buf, off) => {
                    for (let i = 0; i < val.length; i++) {
                        buf[off] = val.length;
                        off++;
                        ieee754.write(buf, val[i], off + 8 * i, false, 52, 8);
                    }
                }
            };
        },
        fromBuf: (buf, off) => {
            checkBufLen(buf, off, 1);
            let val = buf[off], num = [];
            off++;
            checkBufLen(buf, off, 8 * val);
            for (let i = 0; i < val; i++) {
                num.push(ieee754.read(buf, off + i * 8, false, 52, 8));
            }
            return {
                offset: off + val * 8,
                val: num
            };
        }
    },
    0x12: {
        toBuf: val => {
            let lens = [], len = 1;
            for (let i = 0; i < val.length; i++) {
                lens[i] = buffer_1.Buffer.concat([
                    strLenIdent(val[i].length),
                    buffer_1.Buffer.from(val[i])
                ]);
                len += lens[i].length;
            }
            return {
                length: len,
                write: (buf, off) => {
                    buf[off] = val.length;
                    off++;
                    for (let i = 0; i < val.length; i++) {
                        lens[i].copy(buf, off);
                        off += lens[i].length;
                    }
                }
            };
        },
        fromBuf: (buf, off) => {
            checkBufLen(buf, off, 1);
            let len = buf[off], s = [], st;
            off++;
            for (let i = 0; i < len; i++) {
                st = fromLEBuf(buf, off);
                s[i] = st.val;
                off = st.offset;
            }
            return {
                offset: off,
                val: s
            };
        }
    },
    0x20: {
        fromBuf: (buf, off) => {
            checkBufLen(buf, off, 1);
            let st;
            if (buf[off] !== 1)
                throw new Error("Unsupported RPC Definition");
            off++;
            st = fromLEBuf(buf, off);
            off = st.offset;
            checkBufLen(buf, off, 1);
            let name = st.val, parNum = buf[off], par = [], results = [], s = { offset: 0, val: "" }, resNum = 0;
            off++;
            for (let i = 0; i < parNum; i++) {
                let lastPar = {
                    typeId: 0,
                    typeName: "",
                    name: "",
                    default: 0
                };
                checkBufLen(buf, off, 1);
                lastPar.typeId = buf[off];
                lastPar.typeName = typeNames[lastPar.typeId];
                s = fromLEBuf(buf, off);
                lastPar.name = s.val;
                off = s.offset;
                let t = TypesFrom[lastPar.typeId](buf, off);
                lastPar.default = t.val;
                off = t.offset;
                par.push(lastPar);
            }
            checkBufLen(buf, off, 1);
            resNum = buf[off++];
            for (let i = 0; i < resNum; i++) {
                let res = { typeId: 0, typeName: "", name: "" };
                checkBufLen(buf, off, 1);
                res.typeId = buf[off];
                res.typeName = typeNames[res.typeId];
                s = fromLEBuf(buf, off + 1);
                res.name = s.val;
                off = s.offset;
                results.push(res);
            }
            return {
                offset: off,
                val: {
                    name,
                    par,
                    results
                }
            };
        }
    }
};
var TypesFrom = {
    0x00: TypeBuf[0 /* Boolean */].fromBuf,
    0x01: TypeBuf[1 /* Double */].fromBuf,
    0x02: TypeBuf[2 /* String */].fromBuf,
    0x03: TypeBuf[3 /* RawData */].fromBuf,
    0x10: TypeBuf[16 /* BoolArray */].fromBuf,
    0x11: TypeBuf[17 /* DoubleArray */].fromBuf,
    0x12: TypeBuf[18 /* StringArray */].fromBuf,
    0x20: TypeBuf[32 /* RPC */].fromBuf
    //0x21: TypeBuf[e.Byte].fromBuf
};
/**
 * Decodes String where first bytes are length encoded using LEB128
 * @param buf Buffer to red from
 * @param offset position to start reading from
 * @throws LengthError
 */
function fromLEBuf(buf, offset) {
    let res = numFrom128(buf, offset), end = res.offset + res.val;
    checkBufLen(buf, res.offset, res.val);
    return { offset: end, val: buf.slice(res.offset, end).toString("utf8") };
}
function numTo128(num) {
    let n = num;
    let r = [];
    while (n > 0x07f) {
        r.push((n & 0x7f) | 0x80);
        n = n >> 7;
    }
    r.push(n);
    return buffer_1.Buffer.from(r);
}
function numTo2Byte(num) {
    return buffer_1.Buffer.from([(this >> 8) & 0xff, this & 0xff]);
}
/**
 * Decodes a number encoded in LEB128
 * @param buf Buffer to red from
 * @param offset position to start reading from
 * @throws LengthError
 */
function numFrom128(buf, offset) {
    let r = 0, n = buf[offset];
    offset++;
    r = n & 0x7f;
    while (n > 0x7f) {
        checkBufLen(buf, offset, 1);
        n = buf[offset];
        r = (r << 7) + (n & 0x7f);
        offset++;
    }
    return {
        val: r,
        offset
    };
}
/**
 * Error thrown when buffer is too short
 */
class LengthError extends Error {
    constructor(mesg, pos = 0, length = 1) {
        if (typeof mesg !== "string") {
            super(`Trying to read ${length} bytes from position ${pos} of a buffer that is ${mesg.length} long`);
            this.buf = mesg;
            this.position = pos;
        }
        else
            super(mesg);
    }
}
exports.LengthError = LengthError;
/**
 * Check if the Buffer is long enought
 * @param buf Buffer to check the length of
 * @param start Position to read from
 * @param length Number of bytes that will be read
 * @throws LengthError
 */
function checkBufLen(buf, start, length) {
    if (buf.length < start + length - 1)
        throw new LengthError(buf, start, length);
}
