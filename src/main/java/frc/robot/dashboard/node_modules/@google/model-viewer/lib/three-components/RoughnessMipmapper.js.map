{"version":3,"file":"RoughnessMipmapper.js","sourceRoot":"","sources":["../../src/three-components/RoughnessMipmapper.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {LinearMipMapLinearFilter, Mesh, MeshStandardMaterial, NoBlending, OrthographicCamera, PlaneBufferGeometry, RawShaderMaterial, Scene, Vector2, WebGLRenderTarget} from 'three';\nimport {_Math as ThreeMath} from 'three/src/math/Math.js';\n\nimport {Renderer} from './Renderer';\nimport {roughnessToVariance, varianceDefines, varianceToRoughness} from './shader-chunk/common.glsl';\n\nconst $mipmapMaterial = Symbol('mipmapMaterial');\nconst $scene = Symbol('scene');\nconst $flatCamera = Symbol('flatCamera');\nconst $tempTarget = Symbol('tempTarget');\n\n/**\n * The RoughnessMipmapper class allows for the custom generation of mipmaps for\n * the roughness map of a MeshStandardMaterial. This custom mipmapping is based\n * on the normal map, so that as normal variation is lost at deeper mip levels,\n * that loss is encoded as increased roughness to keep reflections consistent\n * across zoom levels and reduce aliasing.\n */\nexport class RoughnessMipmapper {\n  private[$mipmapMaterial] = new MipmapMaterial;\n  private[$scene] = new Scene;\n  private[$flatCamera] = new OrthographicCamera(0, 1, 0, 1, 0, 1);\n  private[$tempTarget]: WebGLRenderTarget|null = null;\n\n  constructor() {\n    this[$scene].add(\n        new Mesh(new PlaneBufferGeometry(2, 2), this[$mipmapMaterial]));\n  }\n\n  generateMipmaps(material: MeshStandardMaterial) {\n    const {threeRenderer} = Renderer.singleton;\n    const {roughnessMap, normalMap} = material;\n    if (roughnessMap == null || normalMap == null ||\n        !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {\n      return;\n    }\n    material.userData.roughnessUpdated = true;\n\n    let width = Math.max(roughnessMap.image.width, normalMap.image.width);\n    let height = Math.max(roughnessMap.image.height, normalMap.image.height);\n    if (!ThreeMath.isPowerOfTwo(width) || !ThreeMath.isPowerOfTwo(height)) {\n      return;\n    }\n\n    const autoClear = threeRenderer.autoClear;\n    threeRenderer.autoClear = false;\n\n    if (this[$tempTarget] == null || this[$tempTarget]!.width !== width ||\n        this[$tempTarget]!.height !== height) {\n      if (this[$tempTarget] != null) {\n        this[$tempTarget]!.dispose();\n      }\n      this[$tempTarget] = new WebGLRenderTarget(\n          width, height, {depthBuffer: false, stencilBuffer: false});\n    }\n\n    if (width !== roughnessMap.image.width ||\n        height !== roughnessMap.image.height) {\n      const newRoughnessTarget = new WebGLRenderTarget(width, height, {\n        minFilter: LinearMipMapLinearFilter,\n        depthBuffer: false,\n        stencilBuffer: false\n      });\n      newRoughnessTarget.texture.generateMipmaps = true;\n      // Setting the render target causes the memory to be allocated.\n      threeRenderer.setRenderTarget(newRoughnessTarget);\n      material.roughnessMap = newRoughnessTarget.texture;\n      if (material.metalnessMap != null) {\n        material.metalnessMap = material.roughnessMap;\n      }\n      if (material.aoMap != null) {\n        material.aoMap = material.roughnessMap;\n      }\n    }\n\n    threeRenderer.setRenderTarget(this[$tempTarget]);\n    this[$mipmapMaterial].uniforms.roughnessMap.value = roughnessMap;\n    this[$mipmapMaterial].uniforms.normalMap.value = normalMap;\n\n    const dpr = threeRenderer.getPixelRatio();\n    const position = new Vector2(0, 0);\n    const texelSize = this[$mipmapMaterial].uniforms.texelSize.value\n    for (let mip = 0; width >= 1 && height >= 1;\n         ++mip, width /= 2, height /= 2) {\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\n      // up a secondary texture to write the result to, then copy it back to the\n      // proper mipmap level.\n      texelSize.set(1.0 / width, 1.0 / height);\n      if (mip == 0) {\n        texelSize.set(0.0, 0.0);\n      }\n\n      threeRenderer.setViewport(\n          position.x, position.y, width / dpr, height / dpr);\n      threeRenderer.render(this[$scene], this[$flatCamera]);\n      threeRenderer.copyFramebufferToTexture(\n          position, material.roughnessMap!, mip);\n      this[$mipmapMaterial].uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (roughnessMap !== material.roughnessMap) {\n      roughnessMap.dispose();\n    }\n\n    threeRenderer.autoClear = autoClear;\n  }\n}\n\nclass MipmapMaterial extends RawShaderMaterial {\n  constructor() {\n    const texelSize = new Vector2(1, 1);\n\n    super({\n      uniforms: {\n        roughnessMap: {value: null},\n        normalMap: {value: null},\n        texelSize: {value: texelSize}\n      },\n\n      vertexShader: `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4( position, 1.0 );\n}\n      `,\n\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform sampler2D roughnessMap;\nuniform sampler2D normalMap;\nuniform vec2 texelSize;\n${varianceDefines}\n${roughnessToVariance}\n${varianceToRoughness}\nvoid main() {\n  gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\n  if (texelSize.x == 0.0) return;\n  float roughness = gl_FragColor.g;\n  float variance = roughnessToVariance(roughness);\n  vec3 avgNormal;\n  for (float x = -1.0; x < 2.0; x += 2.0) {\n    for (float y = -1.0; y < 2.0; y += 2.0) {\n      vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\n      avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\n    }\n  }\n  variance += 1.0 - 0.25 * length(avgNormal);\n  gl_FragColor.g = varianceToRoughness(variance);\n}\n      `,\n\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n\n    this.type = 'RoughnessMipmap';\n  }\n}\n"]}